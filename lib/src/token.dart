import 'package:token_parser/src/lexeme.dart';

abstract class Token implements Match {
  /// The lexeme that generated this token, by matching.
  @override Lexeme pattern;

  /// The value of the input that matched the lexeme.
  @override final String input;

  /// The start position of the token, from the input that matched the lexeme.
  @override final int start;

  /// The end position of the token, from the input that matched the lexeme.
  @override final int end;

  /// ## Token Parser - Token
  /// 
  /// A token is generated by a lexeme, as a result of tokenizing the input.
  /// 
  /// Represents a match of a lexeme against the input, with the context of the lexeme.
  /// Such as, the input, the start and end positions, and the lexeme that generated the token.
  ///
  /// ### Analysing the Token Tree
  /// 
  /// You may use the parsed token to analyze the resulting tree,
  /// using the .get({ Lexeme? lexeme, String? name }) method will get all the tokens that match the lexeme or name.
  /// 
  /// The reach of the search can be limited by using the bool shallow argument,
  /// the default is false when having a lexeme or name, and true when no search parameters are given.
  /// 
  /// ```dart
  /// final result = grammar.parse('two words');
  /// 
  /// final words = result?.get(lexeme: word);
  /// final letters = result?.get(name: 'letter');
  /// 
  /// print('Words: ${ words?.map((token) => match.value) }');
  /// print('Letters: ${ letters?.get(letter).map((token) => match.value) }');
  /// ```
  
  Token(this.pattern, this.input, this.start, this.end);

  /// Creates a token that wraps a match.
  /// 
  /// This is useful when you want to create a token from a match,
  /// it will take the match's pattern, input, start and end.
  factory Token.match(Lexeme pattern, Match match) = TokenMatch;

  /// Creates a token that wraps a list of matches.
  /// 
  /// This is useful when you want to create a token from a list of matches,
  /// it will take the first match's pattern, input, start and last match's end.
  factory Token.matches(Lexeme pattern, List<Match> matches) = TokenParent;

  /// Creates an empty token.
  /// 
  /// This is useful when you want to create a token that doesn't match anything,
  /// but still is not wrong, like for optional lexemes.
  factory Token.emptyAt(Lexeme pattern, String input, int index) => Token.match(pattern, ''.matchAsPrefix(input, index)!);

  @override String? operator [](int group) => this.group(group);
    
  @override String? group(int group) => this[group];
  @override List<String?> groups(List<int> groupIndices) => groupIndices.map(group).toList();
  @override int get groupCount => 0;

  /* -= Identification =- */

  /// The lexeme that generated this token, by matching.
  /// 
  /// Alternative to: `.pattern`
  Lexeme get lexeme => pattern;

  /// The name of the lexeme that generated this token.
  String? get name => lexeme.name;

  /// The value of the token matched by the lexeme.
  String get value => input.substring(start, end);

  @override
  bool operator ==(Object other) =>
    other is Token &&
    lexeme == other.lexeme &&
    input == other.input &&
    samePosition(other);
    
  @override int get hashCode => lexeme.hashCode ^ input.hashCode ^ start.hashCode ^ end.hashCode;

  /// Checks if this token has the same position as another token.
  bool samePosition(Match other) =>
    start == other.start &&
    end == other.end;

  /* -= Children Anaylyzing =- */

  /// List of all the children tokens, shallow.
  /// 
  /// Contains the tokens that were generated by the children of this token's lexeme.
  List<Match> get children => [];

  /// List of all the children tokens, deeply. This contains all the children tokens of the children tokens.
  /// 
  /// Contains the tokens that were generated by the children of this token's lexeme,
  List<Match> get allChildren => [
    ...children,
    ...children.expand((child) => child is Token ? child.allChildren : [])
  ];

  /// Get all the tokens that match the lexeme or name, allows to analyze the resulting tree.
  /// 
  /// The reach of the search can be limited by using the `bool shallow` argument,
  /// the default is `false` when having a lexeme or name, and `true` when no search parameters are given.
  /// 
  /// ```dart
  /// final match = grammar.parse('two words');
  /// 
  /// final words = match?.get(lexeme: word);
  /// final letters = match?.get(name: 'letter');
  /// ```
  List<Token> get<T extends Lexeme>({ T? lexeme, String? name, bool? shallow }) {
    shallow ??= lexeme == null && name == null;
    return (shallow ? children : allChildren).whereType<Token>().where((child) {
      return child.lexeme is T &&
      (lexeme == null || child.lexeme == lexeme) &&
      (name == null || child.name == name);
    }
    ).toList();
  }
}
